# 数据驱动

time: 2019.11.11  
author: heyunjiang

目录

[1 根组件初始化](#1-根组件初始化)  
[2 组件 $mount 方法执行](#2-组件-$mount-方法执行)  

## 说明

本章总结的数据驱动，也叫做 `template -> vtree -> rtree` 的一个转换过程

## 1 根组件初始化

```javascript
// vue 构造函数关键代码
function Vue (options) {
  this._init(options)
}

initMixin(Vue)
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)

export default Vue
```

在 `this._init()` 函数执行过程中，前面都是初始化我们 vue 组件中定义好的 `lifecycle`, `events`, `render`, `injections`, `state`, `provide`。在生命周期初始化之后，数据 injections 初始化之前，会触发生命周期 `beforeCreate`，在数据 provide 初始化完成之后，触发生命周期 `created`。

> 从这里是否可以联想到每个组件的初始化过程？每个组件都有 mixin 初始化，状态 state 初始化，事件 event 初始化，生命周期初始化，渲染 render 初始化

## 2 组件 $mount 方法执行

组件初始化之后，就会调用 $mount 方法，执行挂载。

源码路径 `vue/src/core/instance/lifecycle.js` 的 `mountComponent` 方法  

1. mountComponent 作为 `Vue.prototype.$mount` 的内部直接调用方法
2. mountComponent 作为所有组件渲染的方法

在 `mountComponent` 方法中，主要是定义了 `updateComponent` 方法和实例化了一个 `watcher` 对象

```javascript
let updateComponent = () => {
  vm._update(vm._render(), hydrating)
}

new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate')
      }
    }
}
```

这里只能看出 watcher 调用了 updateComponent 方法，那么它的作用是什么呢？

1. 每个组件都会实例化一个 watcher 对象
2. 调用 updateComponent 来执行 vm._render 生成虚拟节点
3. 调用 vm._update 更新真实节点
4. 监听实例 vm 内部数据变化

那么它的 render 生成虚拟节点，update 更新虚拟节点是怎么操作的呢？它是如何 watch 数据变化的呢？

## 3 组件 render

在组件**实例化**的过程中，会调用 `vm.$mount` 方法渲染，在 $mount 方法过程中，具体又是采用 render 和 update 渲染和更新节点的。  
在组件**初始化**的过程中，我们知道 `vm._render` 是通过 `renderMixin` 方法生成的。

源码路径 `vue/src/core/instance/render.js` 的 `renderMixin` 方法，该方法定义了下列实例原型方法

1. Vue.prototype.$nextTick
2. Vue.prototype._render

下面是 _render 的实现过程

1. 在 _render 方法中，会读取之前我们通过 `compileToFunctions` 方法生成的 vm.$options.render 方法

> 注意点：Vue.prototype._render 和 vm.$options.render 是2个不同名不同用的方法

_render 方法内部的核心实现，是调用了 vm.$options.render 方法，下面是核心代码

```javascript
Vue.prototype._render = function () {
    const vm = this
    const { render, _parentVnode } = vm.$options

    vnode = render.call(vm._renderProxy, vm.$createElement)

    vnode.parent = _parentVnode
    return vnode
}
```

1. 调用 render 方法生成虚拟节点
2. 设置父节点
3. 返回虚拟节点

可以看到 _render 是一个执行的过程，而具体生成虚拟节点，还是要分析 vm.$createElement 方法

>  前面扯了这么多，都是创建虚拟节点的一个过程准备，关键点在 createElement 方法实现

### 3.1 vm.$createElement

源码路径 `vue/src/core/vdom/create-element.js` 的 `_createElement` 方法

先看输入输出定义  
输入：context, tag, data, children, normalizationType  
输出：vnode 

1. context 表示 vm 对象
2. normalizationType 表示如何序列化 children 对象，normalizeChildren + simpleNormalizeChildren 2种序列化方式

关键点：children 序列化 + 生成 vnode 节点
