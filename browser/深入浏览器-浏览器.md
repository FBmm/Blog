# 深入浏览器

目录

1. 浏览器基本构造
2. 浏览器如何加载网页

## 1 浏览器基本构造

1. **用户界面**：地址栏、前进/后退按钮、书签栏、主页按钮、刷新/停止按钮 (除请求页面之后，其他所有内容都是属于用户界面)
2. **UI后端**：用于绘制页面的基本组件，包括 select 、input ... ， 使用操作系统的ui方法实现
3. **数据存储**：浏览器需要实现的有 cookie, localstorage, sessionstorage, cachestorage, indexedDB, websql, filesystem
4. **浏览器引擎**：协调 `ui后端` 与 `渲染引擎` 工作
5. **渲染引擎**：负责获取网页内容(htnml, xml, img, js, css)、生成 dom tree、生成样式表、生成 render tree，然后将内容展示在屏幕上
6. **js引擎**：解析和执行 js 来实现动态网页效果

> 问：浏览器的 `网络模块` 和 `线程控制模块` 位于什么地方？
> 猜想：网络模块位于渲染引擎中，因为渲染引擎负责获取内容

### 1.1 内核

浏览器内核：渲染引擎、js引擎

渲染引擎：负责获取网页内容(htnml, xml, img, js, css)、生成 dom tree、生成样式表、生成 render tree，然后将内容展示在屏幕上

js引擎：解析和执行 js 来实现动态网页效果

> 通常所说的内核，就是浏览器的渲染引擎

### 1.2 常见内核

trident: ie, 360兼容, 搜狗

gecko: firefox

webkit: safari, chrome

blink: chrome opera

> blink 属于 webkit 的一个分支

### 1.3 chrome devtool 解析

在 chrome 中按 `f12` 可以调出开发者工具，可以看到顶部9个具名模块、图标模块

图标模块：主要用于辅助控制页面，包含选取元素、模拟运行环境(pc、手机、平板) ...

9个具名模块

1. Elements:

## 2 浏览器如何加载网页

1. 用户输入网址:  浏览器解析url，检查网址是否正确
2. 选择协议： 检查hsts列表, 采用 http 还是　https
3. dns 查询： 浏览器缓存(chrome://net-internals/#dns), dns 服务器查询(arp 协议)，获取目标 ip 地址
4. tls 4次握手： 见 2.1
5. tcp 3次握手： `syn` -> `syn + ack` -> `ack + data`
6. http 数据请求，服务器返回静态资源
7. dom tree:  浏览器渲染引擎从网络层取得html文档，内部的 HTML 解析器采用 html5 规范规定的解析算法解析文档，构建dom树
8. 样式表对象： 浏览器渲染引擎再次发起 http 请求，获取 html 文档中引入的 css、img、js 文件。css解析会被渲染引擎生成样式表对象， js 会被交给 js引擎处理
9. render tree: 浏览器渲染引擎将生成的 dom tree 和 样式表对象 结合，生成 render tree，每个节点对应有 css 样式值。
10. 页面渲染 见 2.2

> 问题：渲染引擎对于 html 文档及 css, img, js 之间的解析执行顺序是怎么样的？
> 答：html 文档先获取到，然后生成dom tree。然后异步发起http请求，获取 css, img, js 文件，浏览器对发起的http请求个数由限制，大多是6个。请求到的 js 文件，交给浏览器 js引擎处理

### 2.1 tls 4次握手

> 如何加深理解？模拟一次 tls 4次握手

1. 客户端->服务端：`clientHello`、`tls版本`、`可用的加密算法集合`、`可用的压缩算法`、`第一个随机数`
2. 服务端->客户端：`serverHello`、`采用的tls版本`、`采用的加密算法`、`采用的压缩算法`、`ca证书，含公钥`、`第二个随机数`
3. 客户端->服务端: `确认加密结束`、`第三个随机数`、`ack`
4. 服务端->客户端：`确认加密`、`ack`

> 相比与 tcp 的3次握手， tls 的4次握手，就是多了 `tls版本`、`加密算法`、`压缩算法`、`ca证书及公钥`、`随机数`，每次会话都需要进行 tls 4次握手，所以 http2 采用了长链接
> 随机数作用：公钥只是用来加密，非对称加密；随机数用于每次会话生成对称加密；第三个随机数会用第二次握手服务器提供的公钥进行加密

**工作过程**：4次握手结束之后，然后就普通 http 通信了，不过数据都才用会话密钥进行加密传输。这里的会话密钥就是通过那3个随机数、采用的加密算法生成的。比如 RSA密钥交换算法 + 3个随机数 = 特定对称密钥

**公钥作用**：服务器提供的公钥，用于第三个随机数加密

**私钥作用**：服务器解密第三个随机数

**对称密钥作用**：握手之后的 http 通信数据加密

### 2.2 页面渲染

当渲染引擎生成 render tree 之后，就该进行渲染了

1. 根据 render tree 自底向上，通过累加子节点的 width、padding、border、margin，计算每个节点的 preferred 宽度
2. 通过自顶向下，给每个子节点分配可行宽度，计算每个节点的实际宽度
3. 根据 render tree 自底向上，通过应用文字折行、累加子节点 height、padding、border、margin 计算每个子节点的高度
4. 如果元素使用 float、absolute、relative 属性时，进行特殊处理
5. 通过上面的计算结果，构建每个节点的坐标(用于绘制，减少gpu计算量)
6. 分层，成组绘制：将可以成组的部分，分配到同一层，表示同时绘制，每个对象都会被分配到对应的层。每个层有对应的绘制属性，层内部不会被cpu栅格化处理，层之间会被cpu栅格化处理
7. cpu栅格化处理：遍历每层每个对象，计算机执行绘图命令绘制，cpu栅格化处理，创建 `gpu命令` 缓冲区；由浏览器引擎协调 `ui后端` 和 `渲染引擎`，创建合适的 gpu命令
8. GPU绘制：cpu计算出每个层的最终位置，然后 `gpu命令` 缓冲区清空，然后 `gpu命令` 传至gpu，并异步渲染

> 浏览器组成
> 浏览器 js 引擎如何处理 js 代码

参考文章

1. [what-happens-when](https://github.com/skyline75489/what-happens-when-zh_CN)
