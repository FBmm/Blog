## 词法作用域

作用域定义、作用域链、静态/动态作用域

表象解释：javascript采用词法作用域

原理解释：创建执行上下文环境(js 引擎工作过程)

**问：1.什么是作用域？**

答：作用域就是变量和常量的起效范围，只能在该范围内访问该变量

**问：2.作用域有哪些类型？**

答：按作用范围，分为：`全局作用域`、`函数作用域`、`块级作用域(es6)`; 
按作用域链调用顺序，分为：`词法作用域(静态作用域)`、`动态作用域`，javascript采用词法作用域

**问：3.词法作用域和动态作用域怎么区分？**

答：之所以叫词法作用域，词，单词，就是代码编写的时候确定的作用域，动态作用域，就是在代码运行的时候确定

```javascript
/* 例1. 词法作用域 */

var value = 1;
function foo() {console.log(value);}

function bar() {var value = 2;foo();}

bar();
```

**例子分析**：最终输出1，因为javascript采用词法作用域，函数的作用域在编码创建的时候就确定了，运行foo，先查找foo函数本身有没有value，foo本身没有，沿着作用域链向上层查找，找到的上级为value=1。如果采用动态作用域，那么作用域链上级的value就应该是2了

**问：4.作用域链又是什么？是怎么定义的？**

答：作用域链为一个数组栈，保存的是当前函数执行上下文的变量对象+父级执行上下文的变量对象(直到全局作用域)。

> 因为操作作用域链只可能在函数中操作，所以这里说的作用域链就是函数的作用域链，也就是函数变量所在的执行上下文的作用域链属性

关键词：`[[scope]]`、`[[Scopes]]`、`执行上下文`、`执行上下文栈`

创建步骤：在函数执行前创建，执行后销毁，类似钩子函数执行时期

1. 在函数创建的时候，就为其创建了一个内部属性 `[[scope]]`，它的值为一个数组，保存父级执行上下文的作用域链。
2. 在函数正式执行之前，为其创建执行上下文的时候，才为其创建作用域链，也就是其执行上下文添加 `[[Scopes]]` 属性，依次把 `[[scope]]` 、 `函数活动对象AO`(当前函数内部的变量、函数声明)入栈，也就是添加到 `[[Scopes]]` 中，然后函数才真正执行，为 `AO` 赋值，也就是函数内部变量赋值了。
3. 执行完毕，函数的执行上下文出栈被销毁，函数执行上下文中的作用域链也被销毁了。

> 总结：
> 1. 因为函数的内部属性 `[[scope]]` 保存了其父级执行上下文的作用域链，所以函数作用域在其创建的时候就确定了，在其他任何地方调用的值都一样
> 2. 通过本次词法作用域学习，明白了js深入的一点，需要明白js代码解释运行的详细过程。(变量提升、创建作用域链、执行上下文也就成了常事)

**问：5.词法作用域(链)可以更改吗？**

答：原则上是不可更改的，作用域链保存的就是执行上下文相关的变量信息，但是通过eval、with可以改变。eval在函数执行的时候可以动态添加变量，这里就修改了 `AO` ，所以就修改了作用域链。with就更明显了，直接修改包含代码的作用域

**延伸with**

```javascript
var obj = {
  x: 10,
  foo: function () {
    with (this) {
      var x = 20;
      var y = 30;
      console.log(y);//30
    }
  }
};
obj.foo();
console.log(obj.x);//20
console.log(obj.y);//undefined
```

with修改内部代码的作用域，多是操作对象。

**with降低性能**：js引擎通常会对我们写的js代码做静态分析，增加标识符，让我们代码运行的更快；但是不会对我们写的with里面的js代码做静态分析，不会得到优化，如果with里面执行的逻辑较多，那么就会造成严重性能浪费。

> 注意：使用with，js引擎只是不做优化，通常的变量提升还是会有的



